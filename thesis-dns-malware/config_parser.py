import importlib
import json
from typing import Dict, Any, Optional

from ccgen.ccgen import CreditCardGenerator
from malware import base
from malware.schedules import Schedule, TypeA, TypeB
from util import warning, error, validate_ip, info


def parse_client_config(conf: Dict[str, Any]) -> Optional[base.ExfiltrationThread]:
    required_keys = ["client", "data"]
    if not all(key in conf for key in required_keys):
        error(f"Invalid config file provided, all of the following keys are required: {','.join(required_keys)}")
        return None

    common = _parse_common(conf)
    data = _parse_data(conf["data"])
    client = _parse_client(conf["client"], common, data)

    return client


def parse_server_config(conf: Dict[str, Any]) -> Optional[base.Server]:
    if "server" not in conf:
        error(f"Invalid config file provided, missing server entry.")
        return None

    common: Dict[str, Any] = _parse_common(conf)
    server: Optional[base.Server] = _parse_server(conf["server"], common)

    return server


def _parse_common(conf: Dict[str, Any]) -> Dict[str, Any]:
    required_keys = ["malware", "domain"]

    if not all(key in conf for key in required_keys):
        raise ValueError(f"All of the following keys are required: {','.join(required_keys)}")

    return {
        "class": conf["malware"],
        "domain": conf["domain"],
        "log_dir": conf["log_dir"] if 'log_dir' in conf else "/logs"
    }


def _parse_data(conf: Dict[str, Any]):
    """Create data store with provided information."""
    data = dict()

    datum: Dict[str, Any]
    for datum in conf:

        if datum["id"] in data:
            warning(f"[ConfigParser] Duplicate data key '{datum['id']}' in config, using the last provided entry.")

        if datum["source"] == "credit-card":
            data[datum["id"]] = __parse_credit_card_data(datum)

        else:
            warning(f"[ConfigParser] Unknown data source type '{datum['source']}'")

    return data


def _parse_client(conf: Dict[str, Any], common: Dict[str, Any], data_store: Dict[str, Any]) \
        -> Optional[base.ExfiltrationThread]:
    # Parse data for client
    if "data" not in conf:
        error("[ConfigParser] No data provided for client, aborting.")
        return None

    if conf["data"] not in data_store:
        error(f"[ConfigParser] Data with key '{conf['data']}' not found in data store, aborting.")
        return None

    data = data_store[conf["data"]]

    # Parse schedule
    if "schedule" not in conf:
        warning("[ConfigParser] Using default schedule for client.")
        schedule = None
    else:
        schedule = __parse_client_schedule(conf["schedule"])

    # Parse malware arguments
    kwargs = conf["args"] if "args" in conf else dict()

    # Parse DNS settings
    dns_settings = __parse_dns(conf)

    # Import module and instantiate classes
    try:

        module = importlib.import_module(f"malware.{common['class']}")
        malware = getattr(module, "Client")(domain=common["domain"], **kwargs)
        thread = getattr(module, "Exfiltration")(client=malware, dns_settings=dns_settings, schedule=schedule,
                                                 data_source=data, log_dir=common['log_dir'], )
        return thread

    except:
        error(f"[ConfigParser] Fatal error: could not instantiate classes for ({common['class']}).")
        raise


def __parse_dns(conf: Dict[str, any]):
    # Validate DNS settings
    if "dns" not in conf or len(conf["dns"]) != 2:
        warning(f"[ConfigParser] No explicit DNS configuration provided for client.")

        ip = __get_local_dns_resolver()
        port = 53

    else:
        try:
            ip = validate_ip(conf["dns"][0])
            port = int(conf["dns"][1])
        except:
            ip = __get_local_dns_resolver()
            port = 53

    info(f"[ConfigParser] Using DNS server {ip}:{port}")

    return ip, port


def _parse_server(conf: Dict[str, Any], common: Dict[str, Any]) -> Optional[base.Server]:
    # Parse server arguments
    kwargs = conf["args"] if "args" in conf else dict()

    # Import module and instantiate classes
    try:
        module = importlib.import_module(f"malware.{common['class']}")
        server = getattr(module, "Server")(domain=common["domain"], log_dir=common['log_dir'], **kwargs)
        return server

    except:
        error(f"[ConfigParser] Fatal error: could not instantiate classes for ({common['class']}).")
        raise


def __parse_client_schedule(conf: Dict[str, Any]) -> Optional[Schedule]:
    if "type" not in conf:
        return None

    if conf["type"] == "A":
        # Type-A: given range of exfiltrations per fixed interval.

        if "interval" in conf:
            conf["interval"] = int(conf["interval"])
        if "default" not in conf:
            warning("[ConfigParser] No default schedule provided.")
            return None

        conf["default"] = tuple(map(int, conf["default"].split(';')))

        if "override" in conf and conf["override"] is not None:
            overrides = dict()
            for hour in conf["override"]:
                if not 0 <= int(hour) <= 23:
                    warning(f"[ConfigParser] Invalid hour provided in schedule ({hour})")
                    continue
                overrides[int(hour)] = tuple(map(int, conf["override"][hour].split(';')))
            conf["override"] = overrides

        return TypeA(conf)

    elif conf["type"] == "B":
        # Type-B: variable intervals with fixed amount of exfiltrations per hour.

        if "amount" not in conf:
            warning("[ConfigParser] Invalid Type-B schedule provided.")
            return None

        amounts = dict()
        for hour in conf["amount"]:
            if not 0 <= int(hour) <= 23:
                warning(f"[ConfigParser] Invalid hour provided in schedule ({hour})")
                continue
            amount = int(conf["amount"][hour])
            amounts[int(hour)] = (3600 / amount) if amount > 0 else 0

        return TypeB(amounts)

    # Warn for invalid configs
    warning(f"[ConfigParser] Unsupported config type ({conf['type']})")
    return None


def __parse_credit_card_data(subconfig: Dict[str, Any]):
    if "track" not in subconfig or (subconfig["track"] != 1 and subconfig["track"] != 2):
        subconfig["track"] = None
    if "limit" not in subconfig:
        subconfig["limit"] = None
    return CreditCardGenerator(track_type=subconfig["track"], limit=subconfig["limit"])


def __get_local_dns_resolver(file="/etc/resolv.conf"):
    with open(file, "r") as f:
        for line in f:
            line = line.strip()
            if line.startswith("nameserver"):
                return line[11:]
    return None


if __name__ == "__main__":
    with open("configurations/multigrain-01.json", "r") as f:
        cfg = json.load(f)

    client = parse_client_config(cfg)
    client.start()
